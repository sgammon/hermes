~~~~~~~~~~~~~~~~~~~
  Getting Started
~~~~~~~~~~~~~~~~~~~

Welcome to the :py:mod:`apptools` Model API! Using this package, you can model data,
interact with datastore layers through Model Adapters (see: :py:mod:`adapters`),
and generate messages for use with Service classes.

Models in ``apptools`` are dead simple - model classes simply extend
:py:class:`apptools.model.Model` and map properties to their types.
Python's builtin basetypes are used instead of custom property classes::


    # -*- coding: utf-8 -*-
    from apptools import model

    class Person(model.Model):

        ''' A human being. '''

        firstname = basestring
        lastname = basestring, {'required': True}
        age = int


As seen above, the developer can *optionally* set properties to a tuple of
``(<type>, <options>)``, where ``type`` is a supported basetype and ``options``
is a dictionary of arbitrary config.

The following options are supported:

  * ``required``: Raise an exception on-write if this property is left unset.
  * ``repeated``: Raise an exception on-write if this property is not iterable.
  * ``default``: A value to return when this property is accessed but was left unset.
  * ``label``: A human-readable label for the field, for use in autogenerated-forms and schema descriptions.
  * ``description``: A longer, human-readable description, for use in autogenerated-forms and schema descriptions.

Now that you have a Model, you're ready to use it with data!
You can simply instantiate your model and use it as you would a regular Python class::

    # (continued from above)

    # you can set properties in the constructor, as kwargs
    john = Person(firstname='John')

    # you can use attribute syntax...
    john.age = 25

    # you can even use item syntax!
    john['age'] = john.age - 5


.. note :: You'll notice that you are writing to these properties directly. That's okay!
           Under the hood, property descriptors proxy the writes and reads through custom
           :py:class:`apptools.model.Property` instances that are generated from your bindings.

           Thus, your basetypes are safe - you are not actually overwriting their values.


Persistence: Model Adapters
---------------------------

In ``apptools``, a *model adapter* is a class that is used to adapt the modelling layer with
a persistence or serialization engine. Adapters can hook into many parts of the Model API:

* For implementors of :py:class:`apptools.model.adapter.ModelAdapter` (the root ABC for adapters):
    * ``put()``: Delegation of the persistence process.
    * ``get()``: Delegation of the retrieval process.
    * ``encode_key()``: Delegation of the :py:class:`Key` encoding process.

* For implementors of :py:class:`apptools.model.adapter.IndexedModelAdapter` (in *addition* to the above):
    * ``generate_indexes()``: Hook for generating a structure describing indexes that should be written to on put.
    * ``write_indexes()``: Wraps :py:func:`generate_indexes()` (higher-level hook) and delegates the index *writes*

In addition to :py:class:`Model`, :py:class:`Key` and :py:class:`Property`, the Model API ships
with all the base classes to make your own adapters, plus a number of pre-built options:

* :py:class:`apptools.model.adapter.sql.SQLAdapter`: Adapter for SQL-like systems and packages.
* :py:class:`apptools.model.adapter.mongo.MongoAdapter`: Adapter for MongoDB.
* :py:class:`apptools.model.adapter.google.CloudAdapter`: Adapter for Google Cloud Datastore.
* :py:class:`apptools.model.adapter.inmemory.InMemoryAdapter`: A simple in-memory backend,
    * Threadsafe, :py:mod:`gevent` compatible.
    * Mostly used for testing an in-thread safe entity caching.
* :py:class:`apptools.model.adapter.memcache.MemcacheAdapter` Adapter for Memcache.
    * Does **not** support indexing (of course).
    * Can easily be used for transparent model caching.
    * Multiple serialization backends can be used (:py:mod:`msgpack`/:py:mod:`json`, etc).
* :py:class:`apptools.model.adapter.redis.RedisAdapter`: High-performance adapter for Redis.
    * Built upon :py:mod:`redis` and :py:mod:`hiredis`.
    * Supports :py:mod:`gevent`, will appropriately patch and yield.
    * Support for 4 different modes of internal operation.
    * Supports hot-pluggable serialization (:py:mod:`msgpack` & :py:mod:`json` out of the box).


:author: Sam Gammon (sam.gammon@ampush.com)
:copyright: (c) 2013 Ampush.
:license: This is private source code - all rights are reserved. For details about
          embedded licenses and other legalese, see `LICENSE.md`.
